<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Snake - Phaser Edition</title>
    <!-- Phaser library -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <!-- Bootstrap for UI elements -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --primary-color: #BB86FC;
            --secondary-color: #03DAC6;
            --text-color: #FFFFFF;
            --panel-bg: #1E1E1E;
            --danger-color: #CF6679;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #login-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-color);
            z-index: 100;
        }

        .login-panel {
            background-color: var(--panel-bg);
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 90%;
            width: 400px;
            pointer-events: auto;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 2.5rem;
        }

        button {
            background-color: var(--primary-color);
            color: #000;
            border: none;
            padding: 0.7rem 1.5rem;
            border-radius: 4px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            pointer-events: auto;
        }

        button:hover {
            background-color: #9965f4;
        }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(30, 30, 30, 0.8);
            padding: 1rem;
            border-radius: 5px;
            width: 250px;
            pointer-events: auto;
        }

        #leaderboard h2 {
            color: var(--secondary-color);
            margin-bottom: 10px;
            font-size: 1.2rem;
            text-align: center;
        }

        .leader-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leader-pfp {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
            background-color: var(--primary-color);
            overflow: hidden;
        }

        .leader-pfp img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .leader-info {
            flex-grow: 1;
        }

        .leader-name {
            font-weight: bold;
        }

        .leader-score {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .current-player {
            background-color: rgba(187, 134, 252, 0.2);
            border-radius: 4px;
        }

        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(30, 30, 30, 0.8);
            padding: 0.8rem;
            border-radius: 5px;
            pointer-events: auto;
        }

        #stats p {
            margin: 5px 0;
            font-size: 0.9rem;
        }

        #player-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(30, 30, 30, 0.8);
            padding: 0.8rem;
            border-radius: 5px;
            display: flex;
            align-items: center;
            pointer-events: auto;
        }

        #player-info .player-pfp {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
            background-color: var(--primary-color);
            overflow: hidden;
        }

        #player-info .player-pfp img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #player-info .player-name {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .highlight {
            color: var(--secondary-color);
            font-weight: bold;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 50;
        }

        #game-over h2 {
            color: var(--danger-color);
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        #game-over p {
            margin-bottom: 2rem;
            font-size: 1.2rem;
        }

        #game-over .score-panel {
            background-color: var(--panel-bg);
            padding: 2rem;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 2rem;
            width: 80%;
            max-width: 500px;
            pointer-events: auto;
        }

        #game-over .buttons {
            display: flex;
            gap: 1rem;
        }

        #game-over .btn-secondary {
            background-color: var(--panel-bg);
            color: var(--text-color);
        }

        #players-count {
            position: absolute;
            top: 80px;
            left: 20px;
            background-color: rgba(30, 30, 30, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            pointer-events: auto;
        }

        #highscores-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
        }

        #boost-indicator {
            position: absolute;
            top: 80px;
            right: 20px;
            background-color: rgba(255, 50, 50, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            display: none;
            pointer-events: auto;
        }

        #boost-cooldown {
            position: absolute;
            top: 130px;
            right: 20px;
            background-color: rgba(30, 30, 30, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: normal;
            pointer-events: auto;
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background-color: rgba(30, 30, 30, 0.6);
            border: 2px solid var(--secondary-color);
            border-radius: 5px;
            overflow: hidden;
            pointer-events: auto;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .controls-hint {
            position: absolute;
            bottom: 230px;
            right: 20px;
            background-color: rgba(30, 30, 30, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: auto;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            #leaderboard {
                width: 150px;
                font-size: 0.8rem;
            }

            .leader-pfp {
                width: 24px;
                height: 24px;
            }
            
            #player-info {
                flex-direction: column;
                align-items: flex-start;
            }
            
            #player-info .player-pfp {
                margin-bottom: 5px;
            }

            #minimap {
                width: 150px;
                height: 150px;
            }
        }
        
        /* Kill feed styles */
        #kill-feed {
            position: absolute;
            top: 120px;
            right: 20px;
            width: 300px;
            pointer-events: none;
            z-index: 20;
        }
        
        .kill-feed-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .kill-entry {
            background-color: rgba(30, 30, 30, 0.8);
            padding: 8px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            opacity: 0;
            transform: translateX(50px);
            transition: opacity 0.5s, transform 0.5s;
        }
        
        .kill-entry.visible {
            opacity: 1;
            transform: translateX(0);
        }
        
        .kill-entry.fading {
            opacity: 0;
            transform: translateX(-50px);
        }
        
        .kill-entry img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .kill-entry .name {
            margin: 0 5px;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90px;
        }
        
        .kill-entry .killer-name {
            color: #BB86FC;
        }
        
        .kill-entry .victim-name {
            color: #CF6679;
        }
        
        .kill-entry .kill-icon {
            margin: 0 5px;
            color: #FFFFFF;
        }
        
        .kill-entry .points-gained {
            margin-left: auto;
            color: #03DAC6;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            #kill-feed {
                width: 250px;
            }
            
            .kill-entry .name {
                max-width: 70px;
                font-size: 12px;
            }
            
            .kill-entry img {
                width: 20px;
                height: 20px;
            }
        }
        
        /* Chat styles */
        #chat-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            max-width: 90%;
            pointer-events: auto;
            z-index: 30;
        }
        
        #chat-messages {
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            display: none;
        }
        
        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        
        .chat-message-sender {
            font-weight: bold;
            color: #BB86FC;
        }
        
        #chat-input-container {
            display: none;
            flex-direction: row;
            gap: 5px;
        }
        
        #chat-input {
            flex-grow: 1;
            background-color: rgba(30, 30, 30, 0.8);
            border: 1px solid #BB86FC;
            color: white;
            padding: 8px;
            border-radius: 5px;
        }
        
        #chat-send {
            background-color: #BB86FC;
            color: black;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #chat-toggle {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            background-color: #BB86FC;
            color: black;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-container">
        <div id="login-screen">
            <div class="login-panel">
                <h1>Nostr Snake</h1>
                <p>A multiplayer snake game powered by Nostr!</p>
                <button id="connect-nostr">Connect with NIP-07</button>
                <div class="loader" id="login-loader"></div>
                <p id="login-status"></p>
            </div>
        </div>

        <div id="player-info" style="display: none;">
            <div class="player-pfp" id="player-pfp-container">
                <!-- Profile picture will be inserted here -->
            </div>
            <div class="player-name" id="player-name">Player</div>
        </div>

        <div id="leaderboard" style="display: none;">
            <h2>Active Players</h2>
            <div id="leaders-list"></div>
        </div>

        <div id="players-count" style="display: none;">
            <span id="online-count">0</span> players online
        </div>

        <div id="stats" style="display: none;">
            <p>Length: <span id="player-length" class="highlight">0</span></p>
            <p>Score: <span id="player-score" class="highlight">0</span></p>
        </div>

        <div id="boost-indicator"></div>
        <div id="boost-cooldown" style="display: none;">Click to Boost: Ready</div>

        <div class="controls-hint" style="display: none;">
            <p><strong>Controls:</strong></p>
            <p>Mouse: Steer snake</p>
            <p>Click: Boost speed (costs length)</p>
        </div>

        <div id="minimap" style="display: none;">
            <canvas id="minimap-canvas" willReadFrequently="true"></canvas>
        </div>

        <button id="highscores-button" class="btn btn-dark" style="display: none;" onclick="window.open('highscores.html', '_blank')">View High Scores</button>

        <div id="game-over">
            <div class="score-panel">
                <h2>Game Over!</h2>
                <p>Your final score: <span id="final-score">0</span></p>
                <p>Submit your score to the global leaderboard?</p>
                <div class="buttons">
                    <button id="submit-score" class="btn btn-primary">Submit Score</button>
                    <button id="play-again" class="btn btn-secondary">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Configuration
        const GAME_RELAYS = [
            'wss://relay.nostrfreaks.com',
            'wss://relay.damus.io'
        ];
        const METADATA_RELAYS = [
            'wss://relay.nostrfreaks.com',
            'wss://relay.damus.io',
            'wss://purplepag.es'
        ];
        const PRIMARY_RELAY = 'wss://relay.nostrfreaks.com';
        const UPDATE_RATE = 50; // 20 times per second
        const GRID_SIZE = 20;
        const WORLD_SIZE = 5000;
        const INITIAL_SNAKE_LENGTH = 5;
        const FOOD_SPAWN_RATE = 0.01; // Probability of spawning food per frame
        const BOOST_DURATION = 2000; // 2 seconds boost duration (reduced)
        const BOOST_COOLDOWN = 3000; // 3 seconds cooldown
        const BOOST_COST = 3; // Length points
        const NORMAL_SPEED = 300; // Phaser uses pixels per second
        const BOOST_SPEED = 600;
        const GAME_EVENT_KIND = 1000001; // Custom kind for game events
        const HIGHSCORE_KIND = 1000002; // Custom kind for highscores

        // Game state
        let nostrRelays = {}; // Object to store multiple relay connections
        let playerPublicKey = null;
        let playerMetadata = {};
        let leaderboard = [];
        let scoreSubmitted = false;
        let lastUpdateTime = 0;
        let lastStatePublishTime = 0;

        // Phaser game instance
        let game;
        let gameScene;

        // Initialize on page load
        window.onload = function() {
            setupUI();
        };

        // Set up UI elements
        function setupUI() {
            const connectButton = document.getElementById('connect-nostr');
            const playAgainButton = document.getElementById('play-again');
            const submitScoreButton = document.getElementById('submit-score');
            
            connectButton.addEventListener('click', connectWithNostr);
            playAgainButton.addEventListener('click', restartGame);
            submitScoreButton.addEventListener('click', submitHighscore);
        }

        // Connect with Nostr (NIP-07)
        async function connectWithNostr() {
            const loginLoader = document.getElementById('login-loader');
            const loginStatus = document.getElementById('login-status');
            
            loginLoader.style.display = 'block';
            loginStatus.textContent = 'Connecting to Nostr...';
            
            try {
                // Check if NIP-07 extension is available
                if (typeof window.nostr === 'undefined') {
                    throw new Error('Nostr extension not found. Please install a NIP-07 compatible extension like nos2x or Alby.');
                }
                
                // Get public key from NIP-07 extension
                playerPublicKey = await window.nostr.getPublicKey();
                console.log('Connected with pubkey:', playerPublicKey);
                
                // Connect to relay
                await connectToRelay();
                
                // Fetch player metadata
                await fetchPlayerMetadata();
                
                // Update player info display
                updatePlayerInfoDisplay();
                
                // Start the game
                startGame();
                
                // Hide login screen
                document.getElementById('login-screen').style.display = 'none';
                
                // Show UI elements
                document.getElementById('player-info').style.display = 'flex';
                document.getElementById('leaderboard').style.display = 'block';
                document.getElementById('players-count').style.display = 'block';
                document.getElementById('stats').style.display = 'block';
                document.getElementById('minimap').style.display = 'block';
                document.getElementById('highscores-button').style.display = 'block';
                document.getElementById('boost-cooldown').style.display = 'block';
                document.querySelector('.controls-hint').style.display = 'block';
            } catch (error) {
                console.error('Nostr connection error:', error);
                loginStatus.textContent = error.message || 'Failed to connect to Nostr';
                loginLoader.style.display = 'none';
            }
        }

        // Connect to Nostr relay
        async function connectToRelay() {
            return new Promise((resolve, reject) => {
                let connectedCount = 0;
                const requiredConnections = 1; // We need at least the primary relay
                
                // Connect to each game relay
                GAME_RELAYS.forEach(relayUrl => {
                    try {
                        console.log(`Connecting to game relay: ${relayUrl}`);
                        const relay = new WebSocket(relayUrl);
                        nostrRelays[relayUrl] = relay;
                        
                        relay.onopen = () => {
                            console.log(`Connected to game relay: ${relayUrl}`);
                            connectedCount++;
                            
                            // Subscribe to events on this relay
                            subscribeToGameEvents(relay);
                            
                            // If we've connected to enough relays, resolve
                            if (connectedCount >= requiredConnections && relayUrl === PRIMARY_RELAY) {
                                resolve();
                            }
                        };
                        
                        relay.onerror = (error) => {
                            console.error(`Game relay connection error for ${relayUrl}:`, error);
                            // Only reject if it's the primary relay
                            if (relayUrl === PRIMARY_RELAY) {
                                reject(new Error(`Failed to connect to primary Nostr relay: ${relayUrl}`));
                            }
                        };
                        
                        relay.onclose = () => {
                            console.log(`Game relay connection closed: ${relayUrl}`);
                            delete nostrRelays[relayUrl];
                            
                            // Try to reconnect after a delay
                            setTimeout(() => {
                                if (gameScene && !gameScene.gameOver) {
                                    try {
                                        console.log(`Trying to reconnect to ${relayUrl}`);
                                        const newRelay = new WebSocket(relayUrl);
                                        nostrRelays[relayUrl] = newRelay;
                                        
                                        newRelay.onopen = () => {
                                            console.log(`Reconnected to ${relayUrl}`);
                                            subscribeToGameEvents(newRelay);
                                        };
                                        
                                        newRelay.onmessage = handleRelayMessage;
                                        newRelay.onerror = () => console.error(`Error reconnecting to ${relayUrl}`);
                                    } catch (e) {
                                        console.error(`Failed to reconnect to ${relayUrl}:`, e);
                                    }
                                }
                            }, 5000);
                        };
                        
                        relay.onmessage = handleRelayMessage;
                    } catch (error) {
                        console.error(`Error setting up connection to ${relayUrl}:`, error);
                        if (relayUrl === PRIMARY_RELAY) {
                            reject(error);
                        }
                    }
                });
                
                // Set a timeout in case connections take too long
                setTimeout(() => {
                    if (connectedCount === 0) {
                        reject(new Error("Failed to connect to any relays within timeout period"));
                    } else if (connectedCount < GAME_RELAYS.length) {
                        console.warn(`Only connected to ${connectedCount}/${GAME_RELAYS.length} relays, but proceeding`);
                        resolve();
                    }
                }, 5000);
            });
        }

        // Subscribe to game events on the relay
        function subscribeToGameEvents(relay) {
            // Subscribe to game events
            const gameSubscription = JSON.stringify([
                "REQ",
                "game_events_" + Math.random().toString(36).substring(2, 10),
                {
                    "kinds": [GAME_EVENT_KIND],
                    "limit": 100
                }
            ]);
            
            relay.send(gameSubscription);
            
            // Subscribe to metadata for all profiles
            const metadataSubscription = JSON.stringify([
                "REQ",
                "metadata_" + Math.random().toString(36).substring(2, 10),
                {
                    "kinds": [0],
                    "limit": 100
                }
            ]);
            
            relay.send(metadataSubscription);
            
            // Subscribe to highscores
            const highscoreSubscription = JSON.stringify([
                "REQ",
                "highscores_" + Math.random().toString(36).substring(2, 10),
                {
                    "kinds": [HIGHSCORE_KIND],
                    "limit": 50
                }
            ]);
            
            relay.send(highscoreSubscription);
        }

        // Handle messages from the relay
        function handleRelayMessage(event) {
            try {
                const message = JSON.parse(event.data);
                
                if (message[0] === "EVENT") {
                    const eventData = message[2];
                    
                    // Handle different event types
                    if (eventData.kind === GAME_EVENT_KIND) {
                        handleGameEvent(eventData);
                    } else if (eventData.kind === HIGHSCORE_KIND) {
                        // Not needed in main game, handled in highscores.html
                    } else if (eventData.kind === 0) {
                        // Metadata event
                        handleMetadataEvent(eventData);
                    }
                }
            } catch (error) {
                console.error('Error handling relay message:', error);
            }
        }

        // Handle game event messages
        function handleGameEvent(event) {
            if (!gameScene) return;
            
            try {
                const content = JSON.parse(event.content);
                const pubkey = event.pubkey;
                
                // Skip our own events
                if (pubkey === playerPublicKey) {
                    return;
                }
                
                if (content.type === 'position') {
                    // Update other snake position
                    gameScene.updateOtherSnake(pubkey, content);
                } else if (content.type === 'food_eaten') {
                    // Remove food
                    gameScene.removeFood(content.foodId);
                } else if (content.type === 'death') {
                    // Remove other snake
                    gameScene.removeOtherSnake(pubkey);
                } else if (content.type === 'join') {
                    // A new player joined
                    gameScene.addOtherSnake(pubkey, content.position);
                } else if (content.type === 'ate_snake') {
                    // Someone ate another snake
                    if (content.eatenPubkey === playerPublicKey && !gameScene.gameOver) {
                        // We were eaten!
                        gameScene.playerDeath(true, pubkey);
                    } else {
                        // Remove the eaten snake
                        gameScene.removeOtherSnake(content.eatenPubkey);
                        
                        // Update the eater's score
                        gameScene.updateEnemyScore(pubkey, content.scoreGain);
                    }
                }
                
                // Update players count
                document.getElementById('online-count').textContent = Object.keys(gameScene.otherSnakes).length + 1;
            } catch (error) {
                console.error('Error handling game event:', error);
            }
        }

        // Handle metadata event messages
        function handleMetadataEvent(event) {
            try {
                const content = JSON.parse(event.content);
                const pubkey = event.pubkey;
                
                // Store metadata
                playerMetadata[pubkey] = {
                    name: content.name || content.display_name || 'Anonymous',
                    picture: content.picture || null
                };
                
                // Update our player display if this is our metadata
                if (pubkey === playerPublicKey) {
                    updatePlayerInfoDisplay();
                }
                
                // Update display of other snakes
                if (gameScene && gameScene.otherSnakes && gameScene.otherSnakes[pubkey]) {
                    gameScene.updateSnakeMetadata(pubkey, playerMetadata[pubkey]);
                }
                
                // Update leaderboard display
                updateLeaderboardDisplay();
            } catch (error) {
                console.error('Error handling metadata event:', error);
            }
        }

        // Update player info display
        function updatePlayerInfoDisplay() {
            if (!playerPublicKey || !playerMetadata[playerPublicKey]) return;
            
            const metadata = playerMetadata[playerPublicKey];
            const nameElement = document.getElementById('player-name');
            const pfpContainer = document.getElementById('player-pfp-container');
            
            // Update name
            nameElement.textContent = metadata.name;
            
            // Update profile picture
            if (metadata.picture) {
                pfpContainer.innerHTML = '';
                const img = document.createElement('img');
                img.src = metadata.picture;
                img.alt = metadata.name;
                pfpContainer.appendChild(img);
            }
        }

        // Fetch player metadata
        async function fetchPlayerMetadata() {
            return new Promise((resolve, reject) => {
                try {
                    // Try to get metadata directly from the NIP-07 extension first
                    if (window.nostr && window.nostr.getMetadata) {
                        window.nostr.getMetadata()
                            .then(metadata => {
                                console.log('Got metadata from NIP-07:', metadata);
                                playerMetadata[playerPublicKey] = {
                                    name: metadata.name || metadata.display_name || 'Anonymous',
                                    picture: metadata.picture || null
                                };
                                updatePlayerInfoDisplay();
                                resolve();
                            })
                            .catch(error => {
                                console.error('Error getting metadata from NIP-07:', error);
                                // Fallback to querying relays
                                queryMultipleRelaysForMetadata();
                            });
                    } else {
                        // Fallback to querying relays
                        queryMultipleRelaysForMetadata();
                    }
                } catch (error) {
                    console.error('Error fetching player metadata:', error);
                    // Set default metadata
                    playerMetadata[playerPublicKey] = {
                        name: 'Anonymous',
                        picture: null
                    };
                    resolve();
                }
                
                function queryMultipleRelaysForMetadata() {
                    console.log('Querying multiple relays for metadata...');
                    let metadataFound = false;
                    let relayConnections = [];
                    
                    // Try to get metadata from multiple relays
                    METADATA_RELAYS.forEach(relayUrl => {
                        try {
                            const relay = new WebSocket(relayUrl);
                            relayConnections.push(relay);
                            
                            relay.onopen = () => {
                                console.log(`Connected to metadata relay: ${relayUrl}`);
                                
                                // Request metadata for our pubkey
                                const metadataRequest = JSON.stringify([
                                    "REQ",
                                    `metadata_${relayUrl.replace(/[^a-z0-9]/gi, '')}`,
                                    {
                                        "kinds": [0],
                                        "authors": [playerPublicKey],
                                        "limit": 1
                                    }
                                ]);
                                
                                relay.send(metadataRequest);
                            };
                            
                            relay.onmessage = (event) => {
                                try {
                                    const message = JSON.parse(event.data);
                                    
                                    if (message[0] === "EVENT" && message[2].kind === 0 && message[2].pubkey === playerPublicKey) {
                                        const content = JSON.parse(message[2].content);
                                        console.log(`Got metadata from relay ${relayUrl}:`, content);
                                        
                                        metadataFound = true;
                                        playerMetadata[playerPublicKey] = {
                                            name: content.name || content.display_name || 'Anonymous',
                                            picture: content.picture || null
                                        };
                                        
                                        updatePlayerInfoDisplay();
                                        
                                        // Close all relay connections
                                        relayConnections.forEach(r => {
                                            try { r.close(); } catch (e) {}
                                        });
                                        
                                        resolve();
                                    }
                                } catch (error) {
                                    console.error(`Error parsing message from ${relayUrl}:`, error);
                                }
                            };
                            
                            relay.onerror = (error) => {
                                console.error(`Error connecting to metadata relay ${relayUrl}:`, error);
                            };
                        } catch (error) {
                            console.error(`Error setting up connection to ${relayUrl}:`, error);
                        }
                    });
                    
                    // Set a timeout to resolve anyway if we don't get a response
                    setTimeout(() => {
                        // Close all relay connections
                        relayConnections.forEach(relay => {
                            try { relay.close(); } catch (e) {}
                        });
                        
                        if (!metadataFound) {
                            console.log('No metadata found after timeout, using default');
                            playerMetadata[playerPublicKey] = {
                                name: 'Anonymous',
                                picture: null
                            };
                            updatePlayerInfoDisplay();
                        }
                        resolve();
                    }, 5000);
                }
            });
        }

        // Request metadata for a pubkey
        function requestMetadata(pubkey) {
            const metadataQuery = JSON.stringify([
                "REQ",
                "metadata_" + pubkey.slice(0, 10),
                {
                    "kinds": [0],
                    "authors": [pubkey],
                    "limit": 1
                }
            ]);
            
            // Send to primary relay
            if (nostrRelays[PRIMARY_RELAY] && nostrRelays[PRIMARY_RELAY].readyState === WebSocket.OPEN) {
                nostrRelays[PRIMARY_RELAY].send(metadataQuery);
            }
            
            // Also try to fetch from metadata-specific relays
            METADATA_RELAYS.forEach(relayUrl => {
                if (!nostrRelays[relayUrl]) {
                    try {
                        const relay = new WebSocket(relayUrl);
                        
                        relay.onopen = () => {
                            console.log(`Connected to metadata relay: ${relayUrl}`);
                            relay.send(metadataQuery);
                        };
                        
                        relay.onmessage = handleRelayMessage;
                        
                        // Close this connection after a delay
                        setTimeout(() => {
                            try { relay.close(); } catch (e) {}
                        }, 10000);
                    } catch (e) {
                        console.error(`Error connecting to metadata relay ${relayUrl}:`, e);
                    }
                }
            });
        }

        // Update leaderboard
        function updateLeaderboard(pubkey, score) {
            if (!gameScene) return;
            
            // Find existing entry
            const existingIndex = leaderboard.findIndex(entry => entry.pubkey === pubkey);
            
            if (existingIndex !== -1) {
                // Update score
                leaderboard[existingIndex].score = score;
            } else {
                // Add new entry
                leaderboard.push({
                    pubkey: pubkey,
                    score: score
                });
            }
            
            // Sort leaderboard
            leaderboard.sort((a, b) => b.score - a.score);
            
            // Limit to top 10
            leaderboard = leaderboard.slice(0, 10);
            
            // Update display
            updateLeaderboardDisplay();
        }

        // Update leaderboard display
        function updateLeaderboardDisplay() {
            const leadersList = document.getElementById('leaders-list');
            leadersList.innerHTML = '';
            
            leaderboard.forEach(entry => {
                const metadata = playerMetadata[entry.pubkey] || { name: 'Anonymous', picture: null };
                
                const leaderItem = document.createElement('div');
                leaderItem.className = 'leader-item';
                
                if (entry.pubkey === playerPublicKey) {
                    leaderItem.classList.add('current-player');
                }
                
                const pfp = document.createElement('div');
                pfp.className = 'leader-pfp';
                
                if (metadata.picture) {
                    const img = document.createElement('img');
                    img.src = metadata.picture;
                    img.alt = metadata.name;
                    pfp.appendChild(img);
                }
                
                const info = document.createElement('div');
                info.className = 'leader-info';
                
                const name = document.createElement('div');
                name.className = 'leader-name';
                name.textContent = metadata.name;
                
                const score = document.createElement('div');
                score.className = 'leader-score';
                score.textContent = entry.score + ' pts';
                
                info.appendChild(name);
                info.appendChild(score);
                
                leaderItem.appendChild(pfp);
                leaderItem.appendChild(info);
                
                leadersList.appendChild(leaderItem);
            });
        }

        // Publish a game event to the relay
        async function publishGameEvent(content) {
            try {
                const event = {
                    kind: GAME_EVENT_KIND,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [],
                    content: JSON.stringify(content)
                };
                
                // Sign with NIP-07
                const signedEvent = await window.nostr.signEvent(event);
                
                // Publish to all connected relays
                const message = JSON.stringify(["EVENT", signedEvent]);
                
                for (const relayUrl in nostrRelays) {
                    try {
                        const relay = nostrRelays[relayUrl];
                        if (relay.readyState === WebSocket.OPEN) {
                            relay.send(message);
                        }
                    } catch (err) {
                        console.error(`Error sending to relay ${relayUrl}:`, err);
                    }
                }
            } catch (error) {
                console.error('Error publishing game event:', error);
            }
        }
        
        // Publish a highscore to the relay
        async function publishHighscore(score, length) {
            try {
                const event = {
                    kind: HIGHSCORE_KIND,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [],
                    content: JSON.stringify({
                        score: score,
                        length: length,
                        timestamp: Date.now(),
                        game: 'nostr-snake'
                    })
                };
                
                // Sign with NIP-07
                const signedEvent = await window.nostr.signEvent(event);
                
                // Publish to all connected relays
                const message = JSON.stringify(["EVENT", signedEvent]);
                
                for (const relayUrl in nostrRelays) {
                    try {
                        const relay = nostrRelays[relayUrl];
                        if (relay.readyState === WebSocket.OPEN) {
                            relay.send(message);
                        }
                    } catch (err) {
                        console.error(`Error sending highscore to relay ${relayUrl}:`, err);
                    }
                }
                
                return true;
            } catch (error) {
                console.error('Error publishing highscore:', error);
                return false;
            }
        }

        // Submit highscore
        async function submitHighscore() {
            if (!gameScene) return;
            
            // Prevent multiple submissions
            if (scoreSubmitted) return;
            scoreSubmitted = true;
            
            const submitButton = document.getElementById('submit-score');
            submitButton.textContent = 'Submitting...';
            submitButton.disabled = true;
            
            try {
                const success = await publishHighscore(gameScene.score, gameScene.snakeLength);
                
                if (success) {
                    submitButton.textContent = 'Score Submitted!';
                    
                    // Redirect to highscores after a short delay
                    setTimeout(() => {
                        window.open('highscores.html', '_blank');
                    }, 1000);
                } else {
                    throw new Error("Failed to submit score");
                }
            } catch (error) {
                console.error('Error submitting highscore:', error);
                submitButton.textContent = 'Error - Try Again';
                submitButton.disabled = false;
                scoreSubmitted = false;
            }
        }

        // Restart game
        function restartGame() {
            // Hide game over screen
            document.getElementById('game-over').style.display = 'none';
            
            // Reset game state
            if (gameScene) {
                gameScene.restartGame();
            }
            
            scoreSubmitted = false;
        }

        // Start the game
        function startGame() {
            // Configure game
            const config = {
                type: Phaser.AUTO,
                width: window.innerWidth,
                height: window.innerHeight,
                parent: 'game-container',
                backgroundColor: '#121212',
                physics: {
                    default: 'arcade',
                    arcade: {
                        gravity: { x: 0, y: 0 },
                        debug: false
                    }
                },
                scene: [ GameScene ]
            };
            
            // Create game
            game = new Phaser.Game(config);
            
            // Set up resize handler
            window.addEventListener('resize', () => {
                game.scale.resize(window.innerWidth, window.innerHeight);
            });
        }

        // Game Scene
        class GameScene extends Phaser.Scene {
            constructor() {
                super('GameScene');
            }
            
            init() {
                // Game state
                this.gameOver = false;
                this.score = 0;
                this.snakeLength = INITIAL_SNAKE_LENGTH;
                this.otherSnakes = {};
                this.foods = [];
                this.foodSprites = {};
                this.otherSnakeSprites = {};
                this.playerTexts = {};
                this.deltaCache = {};
                
                // Snake state
                this.snakeSegments = [];
                this.snakeGroup = null;
                this.headPosition = null;
                this.snakeAngle = 0;
                this.speed = NORMAL_SPEED;
                this.boosted = false;
                this.boostActive = false;
                this.boostEndTime = 0;
                this.boostCooldown = 0;
                this.boostReady = true;
                
                // Camera
                this.worldSize = WORLD_SIZE;
                this.worldBounds = new Phaser.Geom.Rectangle(0, 0, this.worldSize, this.worldSize);
                
                // Update tracking
                this.lastPositionUpdate = null;
                this.lastUpdateTime = 0;
            }
            
            preload() {
                // No preloaded images - we'll create them programmatically
            }
            
            create() {
                // Reference to game scene for external access
                gameScene = this;
                
                // Set world bounds
                this.physics.world.setBounds(0, 0, this.worldSize, this.worldSize);
                
                // Create grid background
                this.createGrid();
                
                // Create textures programmatically
                this.createTextures();
                
                // Create snake
                this.createSnake();
                
                // Create food group
                this.foodGroup = this.physics.add.group();
                
                // Create other snakes group
                this.otherSnakesGroup = this.physics.add.group();
                
                // Create particle emitter for boost effects
                this.createParticleEmitter();
                
                // Set up camera
                this.cameras.main.setBounds(0, 0, this.worldSize, this.worldSize);
                
                // Set up input
                this.input.on('pointerdown', this.activateBoost, this);
                
                // Initialize minimap
                this.initMinimap();
                
                // Spawn initial food
                for (let i = 0; i < 200; i++) {
                    this.spawnFood();
                }
                
                // Send join event
                this.sendJoinEvent();
                
                // Start checking for food collisions
                this.physics.add.overlap(this.snakeGroup, this.foodGroup, this.eatFood, null, this);
            }
            
            createTextures() {
                // Create graphics for textures
                const graphics = this.add.graphics();
                
                // Create head texture (circle)
                graphics.clear();
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(10, 10, 10);
                graphics.generateTexture('head', 20, 20);
                
                // Create segment texture (circle)
                graphics.clear();
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(10, 10, 10);
                graphics.generateTexture('segment', 20, 20);
                
                // Create food texture (circle)
                graphics.clear();
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(10, 10, 10);
                graphics.generateTexture('food', 20, 20);
                
                // Create particle texture (small circle)
                graphics.clear();
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(4, 4, 4);
                graphics.generateTexture('particle', 8, 8);
                
                // Create grid texture (rectangle with border)
                graphics.clear();
                graphics.lineStyle(1, 0xffffff, 0.1);
                graphics.strokeRect(0, 0, 50, 50);
                graphics.generateTexture('grid', 50, 50);
                
                // Destroy the graphics object as we don't need it anymore
                graphics.destroy();
            }
            
            createParticleEmitter() {
                this.boostParticles = this.add.particles('particle');
                this.boostEmitter = this.boostParticles.createEmitter({
                    speed: { min: 50, max: 100 },
                    angle: { min: 0, max: 360 },
                    scale: { start: 1, end: 0 },
                    lifespan: { min: 200, max: 400 },
                    alpha: { start: 0.8, end: 0 },
                    tint: 0xff5500,
                    on: false
                });
            }
            
            createGrid() {
                // Create a grid of tiles
                this.gridGroup = this.add.group();
                
                const tileSize = 100;
                const numTiles = this.worldSize / tileSize;
                
                for (let x = 0; x < numTiles; x++) {
                    for (let y = 0; y < numTiles; y++) {
                        const tile = this.add.image(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 'grid');
                        tile.setAlpha(0.1);
                        this.gridGroup.add(tile);
                    }
                }
            }
            
            createSnake() {
                // Start at a random position
                const startX = this.worldSize / 2 + (Math.random() * 1000 - 500);
                const startY = this.worldSize / 2 + (Math.random() * 1000 - 500);
                
                // Set up the snake group
                this.snakeGroup = this.physics.add.group();
                
                // Create the head
                this.head = this.snakeGroup.create(startX, startY, 'head');
                this.head.setCircle(10);
                this.head.setDepth(10);
                
                // If we have a profile picture, use it for the head
                if (playerPublicKey && playerMetadata[playerPublicKey] && playerMetadata[playerPublicKey].picture) {
                    this.loadProfilePictureForHead();
                }
                
                // Create initial segments
                this.headPosition = { x: startX, y: startY };
                this.snakeSegments = [{ x: startX, y: startY }];
                
                for (let i = 1; i < this.snakeLength; i++) {
                    const segment = this.snakeGroup.create(startX - i * 20, startY, 'segment');
                    segment.setCircle(10);
                    segment.setDepth(5);
                    this.snakeSegments.push({ x: startX - i * 20, y: startY });
                }
                
                // Set up camera to follow the head
                this.cameras.main.startFollow(this.head, true);
            }
            
            loadProfilePictureForHead() {
                if (!playerPublicKey || !playerMetadata[playerPublicKey] || !playerMetadata[playerPublicKey].picture) return;
                
                // Create a texture from the profile picture URL
                const url = playerMetadata[playerPublicKey].picture;
                const key = 'profile-' + playerPublicKey;
                
                // Check if texture already exists
                if (this.textures.exists(key)) {
                    this.head.setTexture(key);
                    return;
                }
                
                // Create an image element to load the profile picture
                const image = new Image();
                image.crossOrigin = 'anonymous'; // Allow cross-origin loading
                
                image.onload = () => {
                    try {
                        // Create a canvas for the circular mask
                        const canvas = document.createElement('canvas');
                        canvas.width = 20; // Match the head size
                        canvas.height = 20; // Match the head size
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        
                        // Draw a circular mask
                        ctx.beginPath();
                        ctx.arc(10, 10, 10, 0, Math.PI * 2);
                        ctx.closePath();
                        ctx.clip();
                        
                        // Draw the image scaled to fit
                        ctx.drawImage(image, 0, 0, 20, 20);
                        
                        // Create texture from canvas
                        this.textures.addCanvas(key, canvas);
                        
                        // Set the head texture
                        this.head.setTexture(key);
                    } catch (e) {
                        console.error('Error creating profile texture:', e);
                    }
                };
                
                image.onerror = () => {
                    console.error('Error loading profile image:', url);
                };
                
                // Start loading the image
                image.src = url;
            }
            
            initMinimap() {
                // Set up minimap canvas
                this.minimapCanvas = document.getElementById('minimap-canvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d', { willReadFrequently: true });
                this.minimapCanvas.width = 200;
                this.minimapCanvas.height = 200;
                
                // Update minimap
                this.updateMinimapHandler = () => this.updateMinimap();
                this.time.addEvent({
                    delay: 200,
                    callback: this.updateMinimapHandler,
                    loop: true
                });
            }
            
            updateMinimap() {
                if (this.gameOver) return;
                
                // Clear canvas
                this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
                
                // Draw background
                this.minimapCtx.fillStyle = 'rgba(30, 30, 30, 0.6)';
                this.minimapCtx.fillRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
                
                // Calculate scale ratio
                const scale = this.minimapCanvas.width / this.worldSize;
                
                // Draw world boundaries
                this.minimapCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                this.minimapCtx.lineWidth = 2;
                this.minimapCtx.strokeRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
                
                // Draw food
                this.minimapCtx.fillStyle = '#8888ff';
                for (const food of this.foods) {
                    this.minimapCtx.beginPath();
                    this.minimapCtx.arc(
                        food.x * scale,
                        food.y * scale,
                        2,
                        0,
                        Math.PI * 2
                    );
                    this.minimapCtx.fill();
                }
                
                // Draw other snakes
                this.minimapCtx.fillStyle = '#ffff00';
                for (const pubkey in this.otherSnakes) {
                    const snake = this.otherSnakes[pubkey];
                    if (snake.segments.length > 0) {
                        const head = snake.segments[0];
                        this.minimapCtx.beginPath();
                        this.minimapCtx.arc(
                            head.x * scale,
                            head.y * scale,
                            3,
                            0,
                            Math.PI * 2
                        );
                        this.minimapCtx.fill();
                    }
                }
                
                // Draw player snake
                if (this.snakeSegments.length > 0) {
                    // Draw head
                    this.minimapCtx.fillStyle = '#ff0000';
                    this.minimapCtx.beginPath();
                    this.minimapCtx.arc(
                        this.snakeSegments[0].x * scale,
                        this.snakeSegments[0].y * scale,
                        4,
                        0,
                        Math.PI * 2
                    );
                    this.minimapCtx.fill();
                    
                    // Draw viewport
                    const camera = this.cameras.main;
                    const viewportX = (camera.scrollX) * scale;
                    const viewportY = (camera.scrollY) * scale;
                    const viewportWidth = (camera.width) * scale;
                    const viewportHeight = (camera.height) * scale;
                    
                    this.minimapCtx.strokeStyle = '#03DAC6';
                    this.minimapCtx.lineWidth = 1;
                    this.minimapCtx.strokeRect(
                        viewportX,
                        viewportY,
                        viewportWidth,
                        viewportHeight
                    );
                }
            }
            
            spawnFood() {
                // Find a random position
                const x = Math.floor(Math.random() * this.worldSize);
                const y = Math.floor(Math.random() * this.worldSize);
                
                // Create food object
                const food = {
                    id: Math.random().toString(36).substring(2, 15),
                    x: x,
                    y: y,
                    value: Math.floor(Math.random() * 5) + 1
                };
                
                // Create food sprite
                const foodSprite = this.foodGroup.create(x, y, 'food');
                foodSprite.setCircle(10);
                foodSprite.setData('id', food.id);
                foodSprite.setData('value', food.value);
                
                // Scale based on value
                const scale = 0.5 + (food.value * 0.1);
                foodSprite.setScale(scale);
                
                // Random color
                const colorHue = Math.floor(Math.random() * 360);
                foodSprite.setTint(Phaser.Display.Color.HSLToColor(colorHue / 360, 1, 0.5).color);
                
                // Add to foods array
                this.foods.push(food);
                this.foodSprites[food.id] = foodSprite;
            }
            
            eatFood(snake, foodSprite) {
                // Get food data
                const foodId = foodSprite.getData('id');
                const foodValue = foodSprite.getData('value');
                
                // Remove food sprite
                foodSprite.destroy();
                
                // Remove from foods array
                this.foods = this.foods.filter(f => f.id !== foodId);
                delete this.foodSprites[foodId];
                
                // Increase snake length and score
                this.snakeLength += 1;
                this.score += foodValue;
                
                // Update stats display
                document.getElementById('player-length').textContent = this.snakeLength;
                document.getElementById('player-score').textContent = this.score;
                
                // Update leaderboard
                updateLeaderboard(playerPublicKey, this.score);
                
                // Publish event
                publishGameEvent({
                    type: 'food_eaten',
                    foodId: foodId,
                    position: {
                        x: this.head.x,
                        y: this.head.y
                    }
                });
                
                // Spawn new food
                this.spawnFood();
            }
            
            removeFood(foodId) {
                // Remove food sprite
                if (this.foodSprites[foodId]) {
                    this.foodSprites[foodId].destroy();
                    delete this.foodSprites[foodId];
                }
                
                // Remove from foods array
                this.foods = this.foods.filter(f => f.id !== foodId);
                
                // Spawn new food to replace it
                this.spawnFood();
            }
            
            activateBoost() {
                if (this.gameOver || this.boostActive || Date.now() < this.boostCooldown) return;
                
                // Check if we have enough length
                if (this.snakeLength <= BOOST_COST + 2) {
                    // Flash the boost cooldown indicator
                    const cooldownIndicator = document.getElementById('boost-cooldown');
                    cooldownIndicator.textContent = 'Not enough length!';
                    cooldownIndicator.style.color = '#CF6679';
                    
                    setTimeout(() => {
                        cooldownIndicator.textContent = 'Click to Boost: Ready';
                        cooldownIndicator.style.color = 'white';
                    }, 1000);
                    
                    return;
                }
                
                // Activate boost
                this.boostActive = true;
                this.boosted = true;
                this.boostEndTime = Date.now() + BOOST_DURATION;
                this.speed = BOOST_SPEED;
                
                // Reduce length as a cost
                this.snakeLength -= BOOST_COST;
                document.getElementById('player-length').textContent = this.snakeLength;
                
                // Start boost particles
                this.boostEmitter.startFollow(this.head);
                this.boostEmitter.start();
                
                // Show boost indicator
                this.showBoostIndicator();
                
                // Set cooldown
                this.boostCooldown = Date.now() + BOOST_COOLDOWN;
                this.updateBoostCooldown();
            }
            
            showBoostIndicator() {
                // Show boost indicator
                const boostIndicator = document.getElementById('boost-indicator');
                boostIndicator.style.display = 'block';
                
                // Update the indicator
                this.updateBoostIndicator();
            }
            
            updateBoostIndicator() {
                if (!this.boostActive) return;
                
                const timeLeft = Math.ceil((this.boostEndTime - Date.now()) / 1000);
                const boostIndicator = document.getElementById('boost-indicator');
                
                if (timeLeft > 0) {
                    boostIndicator.textContent = ` BOOST: ${timeLeft}s`;
                    
                    // Update recursively
                    setTimeout(() => this.updateBoostIndicator(), 100);
                } else {
                    boostIndicator.style.display = 'none';
                }
            }
            
            updateBoostCooldown() {
                if (this.gameOver) return;
                
                const cooldownIndicator = document.getElementById('boost-cooldown');
                const timeLeft = Math.ceil((this.boostCooldown - Date.now()) / 1000);
                
                if (timeLeft > 0) {
                    cooldownIndicator.textContent = `Click to Boost: ${timeLeft}s`;
                    cooldownIndicator.style.color = '#888';
                    
                    // Update recursively
                    setTimeout(() => this.updateBoostCooldown(), 100);
                } else {
                    cooldownIndicator.textContent = 'Click to Boost: Ready';
                    cooldownIndicator.style.color = 'white';
                }
            }
            
            addOtherSnake(pubkey, position) {
                if (this.otherSnakes[pubkey]) return;
                
                // Create a new snake object
                const segments = [{ x: position.x, y: position.y }];
                
                // Create initial segments
                for (let i = 1; i < INITIAL_SNAKE_LENGTH; i++) {
                    segments.push({
                        x: position.x - i * 20,
                        y: position.y
                    });
                }
                
                // Create sprites
                const group = this.physics.add.group();
                const sprites = [];
                
                // Create head
                const head = group.create(position.x, position.y, 'head');
                head.setCircle(10);
                head.setDepth(10);
                head.setTint(this.getRandomColor());
                sprites.push(head);
                
                // Create body segments
                for (let i = 1; i < INITIAL_SNAKE_LENGTH; i++) {
                    const segment = group.create(position.x - i * 20, position.y, 'segment');
                    segment.setCircle(10);
                    segment.setDepth(5);
                    segment.setTint(head.tintTopLeft);
                    sprites.push(segment);
                }
                
                // Add snake to otherSnakes
                this.otherSnakes[pubkey] = {
                    segments: segments,
                    angle: position.angle || 0,
                    speed: NORMAL_SPEED,
                    score: 0,
                    length: INITIAL_SNAKE_LENGTH,
                    sprites: sprites,
                    group: group,
                    boosted: false,
                    color: head.tintTopLeft
                };
                
                // Set player name label
                this.createPlayerNameLabel(pubkey);
                
                // Load profile picture if available
                if (playerMetadata[pubkey]) {
                    this.updateSnakeMetadata(pubkey, playerMetadata[pubkey]);
                } else {
                    // Request metadata
                    requestMetadata(pubkey);
                }
                
                // Update players count
                document.getElementById('online-count').textContent = Object.keys(this.otherSnakes).length + 1;
            }
            
            createPlayerNameLabel(pubkey) {
                if (!this.otherSnakes[pubkey]) return;
                
                const metadata = playerMetadata[pubkey] || { name: 'Anonymous' };
                const head = this.otherSnakes[pubkey].sprites[0];
                
                // Create name text
                const nameText = this.add.text(head.x, head.y - 30, metadata.name, {
                    fontFamily: 'Arial',
                    fontSize: '14px',
                    fill: '#ffffff',
                    align: 'center'
                });
                nameText.setOrigin(0.5);
                nameText.setDepth(15);
                
                // Store reference in playerTexts
                this.playerTexts[pubkey] = nameText;
            }
            
            updateSnakeMetadata(pubkey, metadata) {
                if (!this.otherSnakes[pubkey]) return;
                
                // Update player name label
                if (this.playerTexts[pubkey]) {
                    this.playerTexts[pubkey].setText(metadata.name);
                } else {
                    this.createPlayerNameLabel(pubkey);
                }
                
                // Load profile picture for head
                if (metadata.picture) {
                    this.loadProfilePictureForSnake(pubkey, metadata.picture);
                }
            }
            
            loadProfilePictureForSnake(pubkey, url) {
                if (!this.otherSnakes[pubkey]) return;
                
                // Create a texture from the profile picture URL
                const key = 'profile-' + pubkey;
                const head = this.otherSnakes[pubkey].sprites[0];
                
                // Check if texture already exists
                if (this.textures.exists(key)) {
                    head.setTexture(key);
                    return;
                }
                
                // Create an image element to load the profile picture
                const image = new Image();
                image.crossOrigin = 'anonymous'; // Allow cross-origin loading
                
                image.onload = () => {
                    try {
                        // Create a canvas for the circular mask
                        const canvas = document.createElement('canvas');
                        canvas.width = 20; // Match the head size
                        canvas.height = 20; // Match the head size
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        
                        // Draw a circular mask
                        ctx.beginPath();
                        ctx.arc(10, 10, 10, 0, Math.PI * 2);
                        ctx.closePath();
                        ctx.clip();
                        
                        // Draw the image scaled to fit
                        ctx.drawImage(image, 0, 0, 20, 20);
                        
                        // Create texture from canvas
                        this.textures.addCanvas(key, canvas);
                        
                        // Set the head texture
                        head.setTexture(key);
                    } catch (e) {
                        console.error('Error creating profile texture:', e);
                    }
                };
                
                image.onerror = () => {
                    console.error('Error loading profile image:', url);
                };
                
                // Start loading the image
                image.src = url;
            }
            
            updateOtherSnake(pubkey, data) {
                if (!this.otherSnakes[pubkey]) {
                    this.addOtherSnake(pubkey, data.position);
                    return;
                }
                
                const snake = this.otherSnakes[pubkey];
                const head = snake.segments[0];
                
                // Update position
                const targetX = data.position.x;
                const targetY = data.position.y;
                
                // Calculate delta for more efficient network updates
                if (!this.deltaCache[pubkey]) {
                    this.deltaCache[pubkey] = { x: 0, y: 0 };
                }
                
                const delta = {
                    x: targetX - head.x,
                    y: targetY - head.y
                };
                
                this.deltaCache[pubkey] = delta;
                
                // Interpolate position (smoother movement)
                snake.segments[0] = {
                    x: targetX,
                    y: targetY
                };
                
                // Update angle
                snake.angle = data.position.angle;
                
                // Update boost status
                if (data.boosted !== undefined) {
                    snake.boosted = data.boosted;
                }
                
                // Update snake properties
                if (data.score !== undefined) {
                    snake.score = data.score;
                    updateLeaderboard(pubkey, data.score);
                }
                
                if (data.length !== undefined) {
                    snake.length = data.length;
                }
                
                // Update sprites for this frame
                this.updateOtherSnakeSprites(pubkey);
            }
            
            updateOtherSnakeSprites(pubkey) {
                if (!this.otherSnakes[pubkey]) return;
                
                const snake = this.otherSnakes[pubkey];
                const segments = snake.segments;
                const sprites = snake.sprites;
                
                // Update head sprite
                if (sprites.length > 0 && segments.length > 0) {
                    sprites[0].x = segments[0].x;
                    sprites[0].y = segments[0].y;
                    sprites[0].rotation = snake.angle;
                    
                    // Update name text position
                    if (this.playerTexts[pubkey]) {
                        this.playerTexts[pubkey].x = segments[0].x;
                        this.playerTexts[pubkey].y = segments[0].y - 30;
                    }
                    
                    // Ensure we have enough sprites for segments
                    while (sprites.length < segments.length) {
                        const lastSprite = sprites[sprites.length - 1];
                        const newSprite = snake.group.create(lastSprite.x, lastSprite.y, 'segment');
                        newSprite.setCircle(10);
                        newSprite.setDepth(5);
                        newSprite.setTint(sprites[0].tintTopLeft);
                        sprites.push(newSprite);
                    }
                    
                    // Update segment sprites
                    for (let i = 1; i < Math.min(segments.length, sprites.length); i++) {
                        sprites[i].x = segments[i].x;
                        sprites[i].y = segments[i].y;
                    }
                    
                    // Apply boost effect if snake is boosted
                    if (snake.boosted) {
                        // Change color to orange
                        const boostTint = 0xff5500;
                        for (const sprite of sprites) {
                            sprite.setTint(boostTint);
                        }
                    } else {
                        // Reset to normal color
                        for (const sprite of sprites) {
                            sprite.setTint(snake.color);
                        }
                    }
                }
            }
            
            removeOtherSnake(pubkey) {
                if (!this.otherSnakes[pubkey]) return;
                
                // Destroy sprites
                this.otherSnakes[pubkey].sprites.forEach(sprite => sprite.destroy());
                
                // Destroy name text
                if (this.playerTexts[pubkey]) {
                    this.playerTexts[pubkey].destroy();
                    delete this.playerTexts[pubkey];
                }
                
                // Remove from otherSnakes
                delete this.otherSnakes[pubkey];
                
                // Clear from delta cache
                delete this.deltaCache[pubkey];
                
                // Update players count
                document.getElementById('online-count').textContent = Object.keys(this.otherSnakes).length + 1;
            }
            
            updateEnemyScore(pubkey, scoreGain) {
                if (!this.otherSnakes[pubkey]) return;
                
                // Update score
                this.otherSnakes[pubkey].score = (this.otherSnakes[pubkey].score || 0) + (scoreGain || 0);
                this.otherSnakes[pubkey].length = (this.otherSnakes[pubkey].length || INITIAL_SNAKE_LENGTH) + Math.floor((scoreGain || 0) / 3);
                
                // Update leaderboard
                updateLeaderboard(pubkey, this.otherSnakes[pubkey].score);
            }
            
            eatEnemySnake(enemyPubkey) {
                if (!this.otherSnakes[enemyPubkey]) return;
                
                const enemy = this.otherSnakes[enemyPubkey];
                
                // Calculate score gain
                const scoreGain = Math.floor(enemy.length / 2);
                
                // Add to score and length
                this.score += scoreGain;
                this.snakeLength += Math.floor(scoreGain / 3);
                
                // Update stats display
                document.getElementById('player-length').textContent = this.snakeLength;
                document.getElementById('player-score').textContent = this.score;
                
                // Publish event
                publishGameEvent({
                    type: 'ate_snake',
                    eatenPubkey: enemyPubkey,
                    position: {
                        x: this.head.x,
                        y: this.head.y
                    },
                    scoreGain: scoreGain
                });
                
                // Remove enemy snake
                this.removeOtherSnake(enemyPubkey);
                
                // Update leaderboard
                updateLeaderboard(playerPublicKey, this.score);
            }
            
            playerDeath(wasEaten = false, eaterPubkey = null) {
                if (this.gameOver) return;
                
                this.gameOver = true;
                
                // Stop boost effects
                this.boostEmitter.stop();
                this.boostActive = false;
                
                // Hide boost indicators
                document.getElementById('boost-indicator').style.display = 'none';
                document.getElementById('boost-cooldown').style.display = 'none';
                
                // Show death message
                let deathMessage = "";
                if (wasEaten && eaterPubkey && playerMetadata[eaterPubkey]) {
                    deathMessage = `You were eaten by ${playerMetadata[eaterPubkey].name}!`;
                }
                
                // Publish death event
                publishGameEvent({
                    type: 'death',
                    position: {
                        x: this.head.x,
                        y: this.head.y
                    },
                    score: this.score,
                    wasEaten: wasEaten,
                    eaterPubkey: eaterPubkey
                });
                
                // Update game over screen
                document.getElementById('final-score').textContent = this.score;
                
                // Show death message if eaten
                if (deathMessage) {
                    let deathElem = document.querySelector('#game-over .score-panel p.death-message');
                    if (!deathElem) {
                        deathElem = document.createElement('p');
                        deathElem.className = 'death-message';
                        deathElem.style.color = '#CF6679';
                        const scorePanel = document.querySelector('#game-over .score-panel');
                        scorePanel.insertBefore(deathElem, scorePanel.querySelector('p:last-of-type'));
                    }
                    deathElem.textContent = deathMessage;
                }
                
                // Show game over screen
                document.getElementById('game-over').style.display = 'flex';
                
                // Enable or disable submit button based on whether we have a valid score
                const submitButton = document.getElementById('submit-score');
                submitButton.disabled = this.score <= 0;
            }
            
            restartGame() {
                // Reset game state
                this.gameOver = false;
                this.score = 0;
                this.snakeLength = INITIAL_SNAKE_LENGTH;
                
                // Update stats display
                document.getElementById('player-length').textContent = this.snakeLength;
                document.getElementById('player-score').textContent = this.score;
                
                // Clear boost state
                this.boostActive = false;
                this.boosted = false;
                this.boostEndTime = 0;
                this.boostCooldown = 0;
                this.speed = NORMAL_SPEED;
                
                // Reset boost indicator
                document.getElementById('boost-indicator').style.display = 'none';
                document.getElementById('boost-cooldown').textContent = 'Click to Boost: Ready';
                document.getElementById('boost-cooldown').style.color = 'white';
                document.getElementById('boost-cooldown').style.display = 'block';
                
                // Destroy current snake
                this.snakeGroup.clear(true, true);
                this.snakeSegments = [];
                
                // Clear other snakes
                for (const pubkey in this.otherSnakes) {
                    this.removeOtherSnake(pubkey);
                }
                
                // Clear food
                this.foodGroup.clear(true, true);
                this.foods = [];
                this.foodSprites = {};
                
                // Create new snake
                this.createSnake();
                
                // Spawn new food
                for (let i = 0; i < 200; i++) {
                    this.spawnFood();
                }
                
                // Send join event
                this.sendJoinEvent();
                
                // Set up collision detection again
                this.physics.add.overlap(this.snakeGroup, this.foodGroup, this.eatFood, null, this);
            }
            
            sendJoinEvent() {
                publishGameEvent({
                    type: 'join',
                    position: {
                        x: this.head.x,
                        y: this.head.y,
                        angle: this.snakeAngle
                    }
                });
            }
            
            sendPositionUpdate() {
                const currentTime = Date.now();
                if (currentTime - lastStatePublishTime < UPDATE_RATE) {
                    return; // Only update at the specified rate
                }
                
                lastStatePublishTime = currentTime;
                
                // Only send update if position has changed
                if (!this.lastPositionUpdate) {
                    this.lastPositionUpdate = { x: this.head.x, y: this.head.y, angle: this.snakeAngle };
                }
                
                const dx = this.head.x - this.lastPositionUpdate.x;
                const dy = this.head.y - this.lastPositionUpdate.y;
                const da = this.snakeAngle - this.lastPositionUpdate.angle;
                
                if (Math.sqrt(dx * dx + dy * dy) > 20 || Math.abs(da) > 0.1) {
                    publishGameEvent({
                        type: 'position',
                        position: {
                            x: this.head.x,
                            y: this.head.y,
                            angle: this.snakeAngle
                        },
                        score: this.score,
                        length: this.snakeLength,
                        boosted: this.boosted
                    });
                    
                    this.lastPositionUpdate = { x: this.head.x, y: this.head.y, angle: this.snakeAngle };
                }
            }
            
            getRandomColor() {
                return Phaser.Display.Color.HSLToColor(Math.random(), 1, 0.5).color;
            }
            
            update(time, delta) {
                if (this.gameOver) return;
                
                // Get pointer position
                const pointer = this.input.activePointer;
                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                
                // Calculate angle towards pointer
                const dx = worldPoint.x - this.head.x;
                const dy = worldPoint.y - this.head.y;
                this.snakeAngle = Math.atan2(dy, dx);
                
                // Rotate head
                this.head.rotation = this.snakeAngle;
                
                // Check if boost has ended
                if (this.boostActive && Date.now() > this.boostEndTime) {
                    // End boost
                    this.boostActive = false;
                    this.boosted = false;
                    this.speed = NORMAL_SPEED;
                    this.boostEmitter.stop();
                    document.getElementById('boost-indicator').style.display = 'none';
                }
                
                // Move head in the direction of angle
                const velocity = new Phaser.Math.Vector2();
                velocity.setToPolar(this.snakeAngle, this.speed);
                
                this.head.x += velocity.x * (delta / 1000);
                this.head.y += velocity.y * (delta / 1000);
                
                // Update head position in segments array
                this.snakeSegments[0] = { x: this.head.x, y: this.head.y };
                
                // Update boost particles
                if (this.boostActive) {
                    this.boostEmitter.setPosition(this.head.x, this.head.y);
                }
                
                // Update rest of the snake
                this.updateSnakeBody();
                
                // Check for collisions with other snakes
                this.checkSnakeCollisions();
                
                // Check for wall collisions
                this.checkWallCollisions();
                
                // Update other snakes segments
                this.updateOtherSnakes();
                
                // Maybe spawn new food
                if (Math.random() < FOOD_SPAWN_RATE) {
                    this.spawnFood();
                }
                
                // Send position update
                this.sendPositionUpdate();
            }
            
            updateSnakeBody() {
                // Update segments
                for (let i = this.snakeSegments.length - 1; i > 0; i--) {
                    // Get direction to previous segment
                    const prevSeg = this.snakeSegments[i - 1];
                    const currentSeg = this.snakeSegments[i];
                    
                    // Calculate distance
                    const dx = prevSeg.x - currentSeg.x;
                    const dy = prevSeg.y - currentSeg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Move toward previous segment
                    if (distance > 20) {
                        const angle = Math.atan2(dy, dx);
                        const newX = currentSeg.x + Math.cos(angle) * (distance - 20);
                        const newY = currentSeg.y + Math.sin(angle) * (distance - 20);
                        
                        this.snakeSegments[i] = { x: newX, y: newY };
                        
                        // Update sprite
                        if (i < this.snakeGroup.getChildren().length) {
                            const sprite = this.snakeGroup.getChildren()[i];
                            sprite.x = newX;
                            sprite.y = newY;
                        }
                    }
                }
                
                // Add or remove segments to match the target length
                while (this.snakeSegments.length > this.snakeLength) {
                    this.snakeSegments.pop();
                    
                    if (this.snakeGroup.getChildren().length > this.snakeSegments.length) {
                        const lastChild = this.snakeGroup.getChildren()[this.snakeGroup.getChildren().length - 1];
                        lastChild.destroy();
                    }
                }
                
                while (this.snakeSegments.length < this.snakeLength) {
                    const lastSeg = this.snakeSegments[this.snakeSegments.length - 1];
                    const newSeg = { x: lastSeg.x, y: lastSeg.y };
                    this.snakeSegments.push(newSeg);
                    
                    // Create a new sprite for this segment
                    const segment = this.snakeGroup.create(newSeg.x, newSeg.y, 'segment');
                    segment.setCircle(10);
                    segment.setDepth(5);
                }
            }
            
            updateOtherSnakes() {
                for (const pubkey in this.otherSnakes) {
                    const snake = this.otherSnakes[pubkey];
                    
                    if (snake.segments.length < 2) continue;
                    
                    // Apply velocity from delta cache
                    if (this.deltaCache[pubkey]) {
                        const delta = this.deltaCache[pubkey];
                        const head = snake.segments[0];
                        
                        // Interpolation factor (smoother movement)
                        const factor = 0.1;
                        
                        // Apply delta
                        snake.segments[0] = {
                            x: head.x + delta.x * factor,
                            y: head.y + delta.y * factor
                        };
                    }
                    
                    // Update segments (follow the leader)
                    for (let i = 1; i < snake.segments.length; i++) {
                        const prev = snake.segments[i - 1];
                        const current = snake.segments[i];
                        
                        // Get direction to previous segment
                        const dx = prev.x - current.x;
                        const dy = prev.y - current.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Move toward previous segment
                        if (distance > 20) {
                            const angle = Math.atan2(dy, dx);
                            const newX = current.x + Math.cos(angle) * (distance - 20);
                            const newY = current.y + Math.sin(angle) * (distance - 20);
                            
                            snake.segments[i] = { x: newX, y: newY };
                        }
                    }
                    
                    // Update sprites
                    this.updateOtherSnakeSprites(pubkey);
                }
            }
            
            checkWallCollisions() {
                if (
                    this.head.x < 0 || 
                    this.head.x > this.worldSize || 
                    this.head.y < 0 || 
                    this.head.y > this.worldSize
                ) {
                    this.playerDeath();
                }
            }
            
            checkSnakeCollisions() {
                // Check collisions with other snakes
                for (const pubkey in this.otherSnakes) {
                    const snake = this.otherSnakes[pubkey];
                    
                    // Skip if not enough segments
                    if (snake.segments.length < 2) continue;
                    
                    // Check collision with head
                    const enemyHead = snake.segments[0];
                    const dx = this.head.x - enemyHead.x;
                    const dy = this.head.y - enemyHead.y;
                    const headDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (headDistance < 20) {
                        // Head-to-head collision, larger snake wins
                        if (this.snakeLength > snake.length) {
                            this.eatEnemySnake(pubkey);
                        } else {
                            this.playerDeath(true, pubkey);
                        }
                        return;
                    }
                    
                    // Check collision with enemy body
                    for (let i = 1; i < snake.segments.length; i++) {
                        const segment = snake.segments[i];
                        const segDx = this.head.x - segment.x;
                        const segDy = this.head.y - segment.y;
                        const segDistance = Math.sqrt(segDx * segDx + segDy * segDy);
                        
                        if (segDistance < 15) {
                            this.eatEnemySnake(pubkey);
                            return;
                        }
                    }
                }
                
                // Check collision with own body
                for (let i = Math.floor(this.snakeLength / 3); i < this.snakeSegments.length; i++) {
                    const segment = this.snakeSegments[i];
                    const dx = this.head.x - segment.x;
                    const dy = this.head.y - segment.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 15) {
                        this.playerDeath();
                        return;
                    }
                }
            }
        }

// ==================== ENHANCEMENT CODE STARTS HERE ====================

// ==================== CONFIGURATION UPDATES ====================

// Update configuration constants
const UPDATE_RATE = 14.5; // ~69 updates per second (1000ms/69)
const GAME_EVENT_KINDS = {
    HEARTBEAT: 1000001,
    HIGHSCORE: 1000002,
    MOVEMENT: 1000003,
    FOOD_SPAWN: 1000004,
    FOOD_EATEN: 1000005,
    PLAYER_JOIN: 1000006,
    KILL: 1000007,
    BOOST: 1000008,
    DEATH: 1000009,
    CHAT: 1000010
};

// ==================== PROFILE CACHING ====================

// Initialize profile cache
const profileCache = {
    loadFromCache: function() {
        try {
            const cached = localStorage.getItem('nostr_snake_profiles');
            if (cached) {
                const parsed = JSON.parse(cached);
                // Only use cache if it's less than 24 hours old
                if (parsed.timestamp && (Date.now() - parsed.timestamp < 24 * 60 * 60 * 1000)) {
                    return parsed.profiles || {};
                }
            }
        } catch (e) {
            console.error('Error loading profile cache', e);
        }
        return {};
    },
    
    saveToCache: function(profiles) {
        try {
            localStorage.setItem('nostr_snake_profiles', JSON.stringify({
                profiles: profiles,
                timestamp: Date.now()
            }));
        } catch (e) {
            console.error('Error saving profile cache', e);
        }
    }
};

// Load cached profiles at startup
const cachedProfiles = profileCache.loadFromCache();
playerMetadata = {...cachedProfiles};

// Cache profiles periodically
setInterval(() => {
    profileCache.saveToCache(playerMetadata);
}, 60000); // Save every minute

// ==================== KILL FEED SYSTEM ====================

// Add kill feed HTML to the UI
function addKillFeedHTML() {
    const uiContainer = document.getElementById('ui-container');
    
    const killFeedDiv = document.createElement('div');
    killFeedDiv.id = 'kill-feed';
    killFeedDiv.innerHTML = `
        <div class="kill-feed-container">
            <!-- Kill entries will be added here -->
        </div>
    `;
    
    uiContainer.appendChild(killFeedDiv);
}

// Initialize kill feed when page loads
window.addEventListener('load', function() {
    addKillFeedHTML();
});

// Add a kill to the kill feed
function addKillToFeed(killerPubkey, victimPubkey, pointsGained) {
    const killFeedContainer = document.querySelector('.kill-feed-container');
    if (!killFeedContainer) return;
    
    // Get metadata for both players
    const killerMeta = playerMetadata[killerPubkey] || { name: 'Unknown', picture: null };
    const victimMeta = playerMetadata[victimPubkey] || { name: 'Unknown', picture: null };
    
    // Create kill entry element
    const killEntry = document.createElement('div');
    killEntry.className = 'kill-entry';
    
   // Create killer profile picture
    const killerPic = document.createElement('img');
    killerPic.src = killerMeta.picture || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="12" fill="%23BB86FC"/><text x="12" y="16" font-size="12" text-anchor="middle" fill="black">' + (killerMeta.name.charAt(0).toUpperCase()) + '</text></svg>';
    killerPic.alt = killerMeta.name;
    
    // Create killer name
    const killerName = document.createElement('span');
    killerName.className = 'name killer-name';
    killerName.textContent = killerMeta.name;
    
    // Create kill icon
    const killIcon = document.createElement('span');
    killIcon.className = 'kill-icon';
    killIcon.textContent = '';
    
    // Create victim name
    const victimName = document.createElement('span');
    victimName.className = 'name victim-name';
    victimName.textContent = victimMeta.name;
    
    // Create victim profile picture
    const victimPic = document.createElement('img');
    victimPic.src = victimMeta.picture || 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="12" fill="%23BB86FC"/><text x="12" y="16" font-size="12" text-anchor="middle" fill="black">' + (victimMeta.name.charAt(0).toUpperCase()) + '</text></svg>';
    victimPic.alt = victimMeta.name;
    
    // Create points gained
    const points = document.createElement('span');
    points.className = 'points-gained';
    points.textContent = '+' + pointsGained;
    
    // Add all elements to kill entry
    killEntry.appendChild(killerPic);
    killEntry.appendChild(killerName);
    killEntry.appendChild(killIcon);
    killEntry.appendChild(victimName);
    killEntry.appendChild(victimPic);
    killEntry.appendChild(points);
    
    // Add to kill feed
    killFeedContainer.prepend(killEntry);
    
    // Animate entry
    setTimeout(() => {
        killEntry.classList.add('visible');
    }, 50);
    
    // Remove entry after 5 seconds
    setTimeout(() => {
        killEntry.classList.add('fading');
        killEntry.classList.remove('visible');
        
        setTimeout(() => {
            if (killEntry.parentNode === killFeedContainer) {
                killFeedContainer.removeChild(killEntry);
            }
        }, 500);
    }, 5000);
    
    // Limit to 5 entries
    const entries = killFeedContainer.querySelectorAll('.kill-entry');
    if (entries.length > 5) {
        for (let i = 5; i < entries.length; i++) {
            killFeedContainer.removeChild(entries[i]);
        }
    }
    
    // Play sound effect (if game scene exists)
    if (gameScene && gameScene.sound) {
        if (killerPubkey === playerPublicKey) {
            // Player got a kill
            if (gameScene.killSound) {
                gameScene.killSound.play({ volume: 0.5 });
            }
        } else if (victimPubkey === playerPublicKey) {
            // Player was killed
            if (gameScene.deathSound) {
                gameScene.deathSound.play({ volume: 0.5 });
            }
        } else {
            // Another player got a kill
            if (gameScene.otherKillSound) {
                gameScene.otherKillSound.play({ volume: 0.3 });
            }
        }
    }
}

// ==================== KILL COUNTER SYSTEM ====================

// Update GameScene to include kills tracking
class GameSceneEnhanced extends Phaser.Scene {
    constructor() {
        super('GameSceneEnhanced');
    }
    
    init() {
        // Call original init
        GameScene.prototype.init.call(this);
        
        // Add kills tracking
        this.kills = 0;
        this.isPredator = false;
        
        // Ensure otherSnakes have kills property
        for (const pubkey in this.otherSnakes) {
            this.otherSnakes[pubkey].kills = 0;
            this.otherSnakes[pubkey].isPredator = false;
        }
    }
    
    preload() {
        GameScene.prototype.preload.call(this);
        
        // Preload additional assets
        this.load.spritesheet('skull', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAHpSURBVDjLpZNraxNRFIWzUzGCYNEUKQRLQYXi+KL4QOxPtP3RWlARdRBUUBT1F4iQUEF0kHbSJjGmTcyD5PGYN7Uz05lJUrWBJ3KbJ2iaWJyEm3vPufe7Z+9zN5EAEPEwFEVBoXgDjR9VVNrfUW53kS8UMQ9PrEmDnFjt9XocKpXKL9TrdQwGAwFnYtTr9XQikVQkRzE0LczhcBDLHEQpmbvw9C2E3K9htlgSZrGcxF3cNPvA63kSutNVQitN0XC7/SeC1+OZitPI5zRUKh9RKtpYWs9BUA2sVrZgfPuFi/kgdqoG/5RcJJRdNPIWQs5vLCZ90HQb39QqKiUbK7IFXugEsU/5ktCSWmJJ2tLrTkOt26BqNlZzOXw3BPxTZdio1RH0f0FQWJ6KJZo1hzlZZ71ez41GIxwOh72ZywEPOICjqmpXJJKQVEUFpL+Iqoa28l3XncJwOORwOJQ5YM0h42ZlgR9ni5kVZVEIAQddjz4aDodtzthULpcrE4KEtfU1CKk3pA4V0EBR4NyEHsAX9mJ+5RXi4rPtjI2ZF7T9fh8n3YF9sMe5ofd3Du2ch471QCbQF8uY92VgPpmdkQZ9EjaBPngYx/n5+c7MzJPQ+d7+OR3H0Un5BxnQ0dHR1CKHS7wTz7OUzWbVjcZ2JpPJbv8DGxz7FimBjgIAAAAASUVORK5CYII=', { frameWidth: 16, frameHeight: 16 });
        this.load.audio('kill', 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+NAwAAAAAAAAAAAAFhpbmcAAAAPAAAAAwAAA6UAkJCQkJCQkJCQkJCQkJCQkJCQwMDAwMDAwMDAwMDAwMDAwMDA7u7u7u7u7u7u7u7u7u7u7u7u//////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAA6VD5y2lAAAAAAAAAAAAAAAAAAAA/+RQwAAABLBQAbxzAAJqOCDnDeAgBQJkJdGIEQIhBCAhhx+fP8+IAQggBPocQAgBCDmef5CEP/OCEHnBAcEH/5wzh///4IOCfggIPgg5+fwQh//+pVlLy0lFbJqupFQIaCxUMjEylV6l6bzk0pS66UokfBIRaKgb2ew5wzsdjhKrNbDvLDJ5dJKyN6zTUy1Z2s2VsZ0/0VoNzZXz/UorHIpWMa1Gw0MDEwNrEw9C72tC54/VHB0X1RS9kZmrMbKszP/5FLARAASwUCrLPAALDkEK6Q9kRAYlLwW3pbXW2yxdS0/tLS41M1UpyzlVtWtQpZZKkarIlNTWnJrWs41KHI3WdaSlkhkSJH//yH/4/5//5EpqSok4ONWnZrTbtsqTkoW6SSptlTu2UpJNZJL///8xLZK22rZbbJOTk5P/////////////////k2n4Sw4SMaHgcGxvGgqFBYOFBsMgWF/cq9KAQDAEaKDSLbfLeVyXVHBP/lBr/+Bh+s2+/8YnKCvPdN3Svqt9/KJ//6Z1VO/5f8zYwX+t/5t2/wX75d9JO+/1YgXe97nvf+UJDSpiQtUi5IkUZJ//+RSQMoANKGsT+dkAA38XYn89IAGiSRQRqSBJ4wZZnfFQPb6J9SrfwkKFCcKhQTCSKe9JdJCJIc6cKFCcHQnf////////////zb/Nv//////////////////////////+l0u7q5y6TSgNBwyjhtQjGn01MYyUJQqY4CDW3////tbnLq6X/hDgYRJ4uODYOQouHpGQfP//9EZYVC5gOAuIJNvNRe5TEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVX/+RSQVgAVOLsT+ewAAvIXY389gAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDCqqqqqqqqq/+RSwGwAVKLsV+ewACvAXYr89gAKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq');
        this.load.audio('death', 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+NAwAAAAAAAAAAAAFhpbmcAAAAPAAAAAwAAA6UAkJCQkJCQkJCQkJCQkJCQkJCQwMDAwMDAwMDAwMDAwMDAwMDA7u7u7u7u7u7u7u7u7u7u7u7u//////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAA6VD5y2lAAAAAAAAAAAAAAAAAAAA/+RQwAAABLBQAbxzAAJqOCDnDeAgBQJkJdGIEQIhBCAhhx+fP8+IAQggBPocQAgBCDmef5CEP/OCEHnBAcEH/5wzh///4IOCfggIPgg5+fwQh//+pVlLy0lFbJqupFQIaCxUMjEylV6l6bzk0pS66UokfBIRaKgb2ew5wzsdjhKrNbDvLDJ5dJKyN6zTUy1Z2s2VsZ0/0VoNzZXz/UorHIpWMa1Gw0MDEwNrEw9C72tC54/VHB0X1RS9kZmrMbKszP/5FLARAASwUCrLPAALDkEK6Q9kRAYlLwW3pbXW2yxdS0/tLS41M1UpyzlVtWtQpZZKkarIlNTWnJrWs41KHI3WdaSlkhkSJH//yH/4/5//5EpqSok4ONWnZrTbtsqTkoW6SSptlTu2UpJNZJL///8xLZK22rZbbJOTk5P/////////////////k2n4Sw4SMaHgcGxvGgqFBYOFBsMgWF/cq9KAQDAEaKDSLbfLeVyXVHBP/lBr/+Bh+s2+/8YnKCvPdN3Svqt9/KJ//6Z1VO/5f8zYwX+t/5t2/wX75d9JO+/1YgXe97nvf+UJDSpiQtUi5IkUZJ//+RSQMoANKGsT+dkAA38XYn89IAGiSRQRqSBJ4wZZnfFQPb6J9SrfwkKFCcKhQTCSKe9JdJCJIc6cKFCcHQnf////////////zb/Nv//////////////////////////+l0u7q5y6TSgNBwyjhtQjGn01MYyUJQqY4CDW3////tbnLq6X/hDgYRJ4uODYOQouHpGQfP//9EZYVC5gOAuIJNvNRe5TEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVX/+RSQVgAVOLsT+ewAAvIXY389gAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDCqqqqqqqqq/+RSwGwAVKLsV+ewACvAXYr89gAKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq');
        this.load.audio('otherKill', 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+NAwAAAAAAAAAAAAFhpbmcAAAAPAAAAAwAAA3MAZmZmZmZmZmZmZmZmZmZmZmZm09PT09PT09PT09PT09PT09PTmZmZmZmZmZmZmZmZmZmZmZmZ//////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAA3OUoDbwAAAAAAAAAAAAAAAAAAAA/+RAwAAPhsNgBjEMkCJGjmDGeUgkjlLIyM6RRRg5hRHCoZ0iiijCiOERxUkkTJHeaZiIONImQT85Mnl7v+7kCBjpk8vd/ncgcOKKJ5Qoj//yBBw4oooojijyh/yBBxRRR5QopE8+XL3e73eTJ58vd7vd3v///5AgQIGfkkdwhjxwqG1Vl9LI7i8+JkZaFRZyeXJkkxCnB0EAGpTj/xoIBQWNJT/EhkNBX9Skjg2Fxf/5FLAGgAQoM0d7GjAAXIZo7z9AEHBpYh+ICgQGHw0OEREZFIRERWIXGhNYi8SDYoGBQPGfhyKCQeLh0UDRQNCguMCgaNAoJigYKBoUCgoFBAL//wQCggEBAKCAUEA3/8EAn///wQCf//8QCf///8ED///+DQWGRMPBhcyGP9JI2LhwMM4/kSHRsJmgYI/zyGQXFQsHgv/9DMWIZ78+kTzxP/w3GPwmP///DP//8Jppmmp/DgTzTgghoaKLmz4eFRE5l2dqRTE9Y1qPT/+RSwDoADcDHJ+yMAAGsGOP9sBiQnKFqzCimZNM1JpmTTMrNlV86prUzKzUpqWIhSYiBGWIiGPpUTEdqampqaq//VSompqampqampqampr//VSompqampqa1VSo1NSqqqpqampqVGqqlRqaf/UqKpVKjVVKpUf/VVKipVH//YiIiIiJ4icRERERP/ERERESMRETxETxETxETxERERP/ERERESIRERx8cRxE7Ud7yxVyqq9VPCvf5nVtltuYsZb5Dq9/VYs3MMYbtWpV2cPEwQjwoFBCRo/s8d9T/+RSQVIAHANEf7eikAUwWJH2yFJAchw9jDh4+Xm9WXJWEthj6wISXvQIwJGMExNBEeW/hsuJyVXs9uuxFQdaL+9mJM/lrVm/+T4z9n/5UmUzCEOCgQEzE////yhGYLjApA0HwZCYWQSCIRkxMJg////5QSg+F5WTEwmC0mJhMJgsKgmTEwTBME//5MJhMTBaJguTEwmCwqCgmJguJiYJgmC8mJhMFhUFBMnkxMFhUJiYTEwmC0sF4nkxMJhMFhMFxMLEwmCwqCgmJguCYJguJiYTBYVBb//5MJiYLCYJicmJhMFhUT/+RSQbAAGYKUh7YykANQRpP2wlMABaCgmJhMTBaKgmTEwXCoLkxMEwXExMFxMTBMEwXExMJgvJiYmEwmCgmJhMTBaCwmJhMJhMF4mJgmCwmCYLCYJicmJhMFpUJiYmEwmCwmJiYTBYTBcTEwTBaCwmJhMJhMTCYJicmJhMFpUJiYmEwmCwmJiYTBYVBMTBMJguJiYLiYmCYJguJiYTBaVCYmJhMJgsJiYmEwmCwqCYmCYLCYJicmJhMFpUJiYmEwmCwmJiYTBYTBcTEwXExMEwWFQTJiYJguJE8kAgEH//lL/+RSQYwAFzH0j7IShgOcXo/2SHDAbUfg4AwAQBwOgMHQC5GnbIgICAdyICAnIgICDJEHTtkYdpERERERH0vQEBBWQVUBA7a0QpSlOcBBW53d3ZERBd3eULdH/6ogJSdXTpY7ukpSSFtAQHr/uoRqCAlNldOljuwRqUkKEa+YqQRH/sCoFWS8pGUiGkkUhUiqMDsVRAfMl+s1DhQQUgIz//wxDkSCuLIIsFRcEBpP/+pBZDTzaHwEIcRxVrNXF+bq9XFsMBBxYdQBEhL/+RSwNIAGRLEb7ISAANaWI32RFIBGLIomQZMmTJ/yZMmTJk/JoMmTUWf/QsUYjKaW7ChdQ2KjxFf/vCiF//vKzf/SWosC7kPzQfktLS06RXf/qS0tLS0//1LS0tL/+ktLS0/+ktLS0tLS0tLS0tLVJLS0tU62W+z2///9LS1SUyIZiImLUaAqf//yZUZGRKEXOKMAVzOxiYtR4OZ///9aRjIYCZs2bNjP///83w0CqmpqamoXLj5PGNMG//7lv//lBVVVVVVS4Wm1qXLDgU//+OWdZbFvfGFnV/+RSwY4AGUFkf6eigAMYLI/09FADHcllMz8WtutxIICqWW2NjX/////ViYt5uhQKBQKBQ5NF//////9UrMlZksREREPdQKBQKBQKBS3///+q1JWZNSvtv//////jszMzM1JJVbFFF5QqVVVTn///8ZmZmZnOcTExMTFecc/////5mZmZmEQiIid3d3d8Oxd3uPu8zMzNzNIicE8RE8REREzMzNU5nUo2Fy5rERM0hETqGc8YnE46oiEtaiMlb4iJWbTyPFkjqWhpXcVw7qUJc5XHVV2dCnOl//+RSQWAAGLLEb7AWAAMSRo/2BFAEOZxiqu1G5UVLTTzTjRtGUWkx04d0KFd3HZdnWtaSS0tLFyxbi0tLiQxNTIvKOKA3blWWsv1XLVrVMGLcL9P+jYa4UuGjbw0G37hgxb+kNGmXLRt+hjYNH9IYaDRoNmNg0aP6gxsGjQYNhsGj+kdmNg0aP6hsjZGjQbMbI0aP6g2RsNB/SGzGw0H9IbB2GwdI7MbI0f0hsnajYOw0H9QbI2RsHYbDR/SGydqNgbDQa6h2Y2RsHYbDR/UGydqNh6GNh/UGydqNh6GNh/UGydqNh6GNh//+RSQTIAFgFMf5gRgALKKY/xgjAA0OupdBgCqNLorjoTUaNB/UOupdB/qHXUOg/1D8NDrqHQemh1Dw0OuodMPDQ66h0P+oeGh11Dof9Q8ND/UOh/1D8ND/UOh/1D8ND/UOh/1D8ND/UOh/1D8ND/UOh/1D8NDoNDof9Q8NDroNDpDw0OmYR0gwQOWgaHUGh1Dph4aHXQaHQ/6h4aHXQaHQ/6h4aHXQaHQ/6h4aHXQaHQ/6hkOmEaHXQaHQ/6hkOug0wjQ66DQ6Q6YeGh10Gh0P+oeGh10GmEg66DQ6Q6YeGh10Gn/+RSQNIAFFFEb4YRwAKKKI3gwjgD/UPDJDoQ4Gh0h0w8MkOhDgaHSHTD4UwuVMSMFzFkG5VJIxIwWkjBaYkYLTEjBczWCk4aCQaaLCkzVC04aCQaaLCkzVC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQf/+RSQMoAFPNEX4YRyAKMaIvwwjkPNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQfNC04aCQ');
        
        // Create texture for predator glow
        const graphics = this.add.graphics();
        graphics.fillStyle(0xff0000, 1);
        graphics.fillCircle(50, 50, 50);
        graphics.generateTexture('predator-glow', 100, 100);
        graphics.destroy();
    }
    
    create() {
        GameScene.prototype.create.call(this);
        
        // Set up sounds
        this.killSound = this.sound.add('kill');
        this.deathSound = this.sound.add('death');
        this.otherKillSound = this.sound.add('otherKill');
        
        // Create predator effect for player
        this.predatorEffect = this.add.sprite(this.head.x, this.head.y, 'predator-glow');
        this.predatorEffect.setBlendMode(Phaser.BlendModes.ADD);
        this.predatorEffect.setDepth(5);
        this.predatorEffect.setAlpha(0.3);
        this.predatorEffect.setVisible(false);
        
        // Create kill counter for player
        this.killCounter = this.add.text(0, 0, ' 0', {
            fontFamily: 'Arial',
            fontSize: '16px',
            color: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3,
            align: 'center'
        });
        this.killCounter.setDepth(15);
        this.killCounter.setOrigin(0.5);
        this.killCounter.setVisible(false);
        
        // Update player stats display
        const statsDiv = document.getElementById('stats');
        if (statsDiv) {
            const killsP = document.createElement('p');
            killsP.innerHTML = 'Kills: <span id="player-kills" class="highlight">0</span>';
            statsDiv.appendChild(killsP);
        }
    }
    
    updateKillCounter() {
        // Update kill counter text
        this.killCounter.setText(' ' + this.kills);
        
        // Update stats display
        const killsElement = document.getElementById('player-kills');
        if (killsElement) {
            killsElement.textContent = this.kills;
        }
        
        // Update predator status
        if (this.kills >= 3 && !this.isPredator) {
            this.isPredator = true;
            this.predatorEffect.setVisible(true);
            
            // Show message
            const boostIndicator = document.getElementById('boost-indicator');
            boostIndicator.textContent = ' PREDATOR STATUS ACHIEVED! ';
            boostIndicator.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            boostIndicator.style.display = 'block';
            
            setTimeout(() => {
                boostIndicator.style.display = 'none';
            }, 3000);
        }
    }
    
    update(time, delta) {
        // Call original update method
        GameScene.prototype.update.call(this, time, delta);
        
        // Update predator effect
        if (this.isPredator && this.predatorEffect) {
            this.predatorEffect.x = this.head.x;
            this.predatorEffect.y = this.head.y;
            
            // Pulsating effect
            const pulseFactor = 0.5 + Math.abs(Math.sin(time / 500)) * 0.3;
            this.predatorEffect.setScale(pulseFactor);
        }
        
        // Update kill counter position
        if (this.kills > 0 && this.killCounter) {
            this.killCounter.x = this.head.x;
            this.killCounter.y = this.head.y - 40;
            this.killCounter.setVisible(true);
        }
        
        // Update other snakes predator effects
        for (const pubkey in this.otherSnakes) {
            const snake = this.otherSnakes[pubkey];
            
            if (snake.isPredator && snake.predatorEffect && snake.sprites.length > 0) {
                // Update predator effect position
                snake.predatorEffect.x = snake.sprites[0].x;
                snake.predatorEffect.y = snake.sprites[0].y;
                
                // Pulsating effect
                const pulseFactor = 0.5 + Math.abs(Math.sin(time / 500)) * 0.3;
                snake.predatorEffect.setScale(pulseFactor);
            }
            
            // Update kill counter for other snake
            if (snake.kills > 0 && snake.killCounter && snake.sprites.length > 0) {
                snake.killCounter.x = snake.sprites[0].x;
                snake.killCounter.y = snake.sprites[0].y - 40;
            }
        }
    }
    
    eatEnemySnake(enemyPubkey) {
        if (!this.otherSnakes[enemyPubkey]) return;
        
        const enemy = this.otherSnakes[enemyPubkey];
        
        // Calculate score gain
        const scoreGain = Math.floor(enemy.length / 2);
        
        // Add to score and length
        this.score += scoreGain;
        this.snakeLength += Math.floor(scoreGain / 3);
        
        // Update stats display
        document.getElementById('player-length').textContent = this.snakeLength;
        document.getElementById('player-score').textContent = this.score;
        
        // Increment kill counter
        this.kills++;
        this.updateKillCounter();
        
        // Add to kill feed
        addKillToFeed(playerPublicKey, enemyPubkey, scoreGain);
        
        // Publish kill event
        publishGameEvent({
            type: 'kill',
            event_kind: GAME_EVENT_KINDS.KILL,
            eatenPubkey: enemyPubkey,
            position: {
                x: this.head.x,
                y: this.head.y
            },
            scoreGain: scoreGain,
            killer: {
                pubkey: playerPublicKey,
                kills: this.kills,
                isPredator: this.isPredator
            }
        });
        
        // Remove enemy snake
        this.removeOtherSnake(enemyPubkey);
        
        // Update leaderboard
        updateLeaderboard(playerPublicKey, this.score);
    }
    
    createPlayerNameLabel(pubkey) {
        if (!this.otherSnakes[pubkey]) return;
        
        // Call original method
        GameScene.prototype.createPlayerNameLabel.call(this, pubkey);
        
        // Add kill counter for this snake
        const snake = this.otherSnakes[pubkey];
        const head = snake.sprites[0];
        
        snake.killCounter = this.add.text(head.x, head.y - 40, ' 0', {
            fontFamily: 'Arial',
            fontSize: '16px',
            color: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3,
            align: 'center'
        });
        snake.killCounter.setDepth(15);
        snake.killCounter.setOrigin(0.5);
        snake.killCounter.setVisible(false);
    }
    
    updateOtherSnake(pubkey, data) {
        // Call original method
        GameScene.prototype.updateOtherSnake.call(this, pubkey, data);
        
        if (!this.otherSnakes[pubkey]) return;
        
        // Update kill count
        if (data.kills !== undefined) {
            this.otherSnakes[pubkey].kills = data.kills;
            
            // Update kill counter
            if (this.otherSnakes[pubkey].killCounter) {
                this.otherSnakes[pubkey].killCounter.setText(' ' + data.kills);
                this.otherSnakes[pubkey].killCounter.setVisible(data.kills > 0);
            }
        }
        
        // Update predator status
        if (data.isPredator !== undefined) {
            this.otherSnakes[pubkey].isPredator = data.isPredator;
            
            // Add predator effect if not already there
            if (data.isPredator && !this.otherSnakes[pubkey].predatorEffect) {
                const head = this.otherSnakes[pubkey].sprites[0];
                const predatorGlow = this.add.sprite(head.x, head.y, 'predator-glow');
                predatorGlow.setBlendMode(Phaser.BlendModes.ADD);
                predatorGlow.setDepth(5);
                predatorGlow.setAlpha(0.3);
                this.otherSnakes[pubkey].predatorEffect = predatorGlow;
            } else if (!data.isPredator && this.otherSnakes[pubkey].predatorEffect) {
                this.otherSnakes[pubkey].predatorEffect.destroy();
                this.otherSnakes[pubkey].predatorEffect = null;
            }
        }
    }
    
    playerDeath(wasEaten = false, eaterPubkey = null) {
        if (this.gameOver) return;
        
        // Call original method
        GameScene.prototype.playerDeath.call(this, wasEaten, eaterPubkey);
        
        // Add to kill feed if eaten
        if (wasEaten && eaterPubkey) {
            addKillToFeed(eaterPubkey, playerPublicKey, Math.floor(this.snakeLength / 2));
        }
        
        // Hide predator effect
        if (this.predatorEffect) {
            this.predatorEffect.setVisible(false);
        }
        
        // Hide kill counter
        if (this.killCounter) {
            this.killCounter.setVisible(false);
        }
    }
    
    restartGame() {
        // Call original method
        GameScene.prototype.restartGame.call(this);
        
        // Reset kills
        this.kills = 0;
        this.isPredator = false;
        
        // Hide predator effect
        if (this.predatorEffect) {
            this.predatorEffect.setVisible(false);
        }
        
        // Hide kill counter
        if (this.killCounter) {
            this.killCounter.setVisible(false);
        }
        
        // Reset kills display
        const killsElement = document.getElementById('player-kills');
        if (killsElement) {
            killsElement.textContent = '0';
        }
    }
    
    sendPositionUpdate() {
        const currentTime = Date.now();
        if (currentTime - lastStatePublishTime < UPDATE_RATE) {
            return; // Only update at the specified rate (69 times per second)
        }
        
        lastStatePublishTime = currentTime;
        
        // Only send update if position has changed
        if (!this.lastPositionUpdate) {
            this.lastPositionUpdate = { x: this.head.x, y: this.head.y, angle: this.snakeAngle };
        }
        
        const dx = this.head.x - this.lastPositionUpdate.x;
        const dy = this.head.y - this.lastPositionUpdate.y;
        const da = this.snakeAngle - this.lastPositionUpdate.angle;
        
        if (Math.sqrt(dx * dx + dy * dy) > 20 || Math.abs(da) > 0.1) {
            publishGameEvent({
                type: 'position',
                event_kind: GAME_EVENT_KINDS.MOVEMENT,
                position: {
                    x: this.head.x,
                    y: this.head.y,
                    angle: this.snakeAngle
                },
                score: this.score,
                length: this.snakeLength,
                boosted: this.boosted,
                kills: this.kills,
                isPredator: this.isPredator
            });
            
            this.lastPositionUpdate = { x: this.head.x, y: this.head.y, angle: this.snakeAngle };
        }
    }
}

// ==================== OVERRIDE PHASER GAME CREATION ====================

// Override game creation to use enhanced scene
const originalStartGame = startGame;
startGame = function() {
    // Configure game
    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        parent: 'game-container',
        backgroundColor: '#121212',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { x: 0, y: 0 },
                debug: false
            }
        },
        scene: [ GameSceneEnhanced ] // Use enhanced scene
    };
    
    // Create game
    game = new Phaser.Game(config);
    
    // Set up resize handler
    window.addEventListener('resize', () => {
        game.scale.resize(window.innerWidth, window.innerHeight);
    });
};

// ==================== OVERRIDE EVENT HANDLERS ====================

// Update handleGameEvent to use specific event kinds
const originalHandleGameEvent = handleGameEvent;
handleGameEvent = function(event) {
    if (!gameScene) return;
    
    try {
        const content = JSON.parse(event.content);
        const pubkey = event.pubkey;
        
        // Skip our own events
        if (pubkey === playerPublicKey) {
            return;
        }
        
        if (content.type === 'position') {
            // Update other snake position
            gameScene.updateOtherSnake(pubkey, content);
        } else if (content.type === 'food_eaten') {
            // Remove food
            gameScene.removeFood(content.foodId);
        } else if (content.type === 'death') {
            // Remove other snake
            gameScene.removeOtherSnake(pubkey);
        } else if (content.type === 'join') {
            // A new player joined
            gameScene.addOtherSnake(pubkey, content.position);
        } else if (content.type === 'kill') {
            // Someone killed another snake
            if (content.eatenPubkey === playerPublicKey && !gameScene.gameOver) {
                // We were eaten!
                gameScene.playerDeath(true, pubkey);
            } else {
                // Remove the eaten snake
                gameScene.removeOtherSnake(content.eatenPubkey);
                
                // Update the killer's score and kill count
                gameScene.updateEnemyScore(pubkey, content.scoreGain);
                
                // Update kill feed
                addKillToFeed(pubkey, content.eatenPubkey, content.scoreGain);
                
                // Update the killer's metrics
                if (content.killer && gameScene.otherSnakes[pubkey]) {
                    gameScene.otherSnakes[pubkey].kills = content.killer.kills || 0;
                    gameScene.otherSnakes[pubkey].isPredator = content.killer.isPredator || false;
                }
            }
        } else if (content.type === 'chat') {
            // Handle chat message
            window.addChatMessage(pubkey, content.message);
        }
        
        // Update players count
        document.getElementById('online-count').textContent = Object.keys(gameScene.otherSnakes).length + 1;
    } catch (error) {
        console.error('Error handling game event:', error);
    }
};

// Override publishGameEvent to use specific event kinds
const originalPublishGameEvent = publishGameEvent;
publishGameEvent = async function(content) {
    try {
        // Determine event kind based on content.type or content.event_kind
        let kind = GAME_EVENT_KINDS.HEARTBEAT; // Default
        
        if (content.event_kind) {
            kind = content.event_kind;
        } else {
            // Map types to kinds
            switch (content.type) {
                case 'position': kind = GAME_EVENT_KINDS.MOVEMENT; break;
                case 'food_eaten': kind = GAME_EVENT_KINDS.FOOD_EATEN; break;
                case 'death': kind = GAME_EVENT_KINDS.DEATH; break;
                case 'join': kind = GAME_EVENT_KINDS.PLAYER_JOIN; break;
                case 'kill': kind = GAME_EVENT_KINDS.KILL; break;
                case 'boost': kind = GAME_EVENT_KINDS.BOOST; break;
                case 'chat': kind = GAME_EVENT_KINDS.CHAT; break;
            }
        }
        
        const event = {
            kind: kind,
            created_at: Math.floor(Date.now() / 1000),
            tags: [],
            content: JSON.stringify(content)
        };
        
        // Sign with NIP-07
        const signedEvent = await window.nostr.signEvent(event);
        
        // Publish to all connected relays
        const message = JSON.stringify(["EVENT", signedEvent]);
        
        for (const relayUrl in nostrRelays) {
            try {
                const relay = nostrRelays[relayUrl];
                if (relay.readyState === WebSocket.OPEN) {
                    relay.send(message);
                }
            } catch (err) {
                console.error(`Error sending to relay ${relayUrl}:`, err);
            }
        }
    } catch (error) {
        console.error('Error publishing game event:', error);
    }
};

// Override subscribeToGameEvents to subscribe to all event kinds
const originalSubscribeToGameEvents = subscribeToGameEvents;
subscribeToGameEvents = function(relay) {
    // Subscribe to game events for all kinds
    const gameSubscription = JSON.stringify([
        "REQ",
        "game_events_" + Math.random().toString(36).substring(2, 10),
        {
            "kinds": [
                GAME_EVENT_KINDS.HEARTBEAT,
                GAME_EVENT_KINDS.MOVEMENT,
                GAME_EVENT_KINDS.FOOD_SPAWN,
                GAME_EVENT_KINDS.FOOD_EATEN,
                GAME_EVENT_KINDS.PLAYER_JOIN,
                GAME_EVENT_KINDS.KILL,
                GAME_EVENT_KINDS.BOOST,
                GAME_EVENT_KINDS.DEATH,
                GAME_EVENT_KINDS.CHAT
            ],
            "limit": 100
        }
    ]);
    
    relay.send(gameSubscription);
    
    // Subscribe to metadata for all profiles
    const metadataSubscription = JSON.stringify([
        "REQ",
        "metadata_" + Math.random().toString(36).substring(2, 10),
        {
            "kinds": [0],
            "limit": 100
        }
    ]);
    
    relay.send(metadataSubscription);
    
    // Subscribe to highscores
    const highscoreSubscription = JSON.stringify([
        "REQ",
        "highscores_" + Math.random().toString(36).substring(2, 10),
        {
            "kinds": [GAME_EVENT_KINDS.HIGHSCORE],
            "limit": 50
        }
    ]);
    
    relay.send(highscoreSubscription);
};

// ==================== CHAT SYSTEM ====================

// Add chat functionality
function addChatSystem() {
    // Add chat HTML
    const uiContainer = document.getElementById('ui-container');
    
    const chatContainer = document.createElement('div');
    chatContainer.id = 'chat-container';
    chatContainer.innerHTML = `
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Press Enter to chat...">
            <button id="chat-send">Send</button>
        </div>
        <button id="chat-toggle"></button>
    `;
    
    uiContainer.appendChild(chatContainer);
    
    // Set up chat functionality
    const chatToggle = document.getElementById('chat-toggle');
    const chatMessages = document.getElementById('chat-messages');
    const chatInputContainer = document.getElementById('chat-input-container');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    
    let chatOpen = false;
    
    chatToggle.addEventListener('click', () => {
        chatOpen = !chatOpen;
        
        if (chatOpen) {
            chatMessages.style.display = 'block';
            chatInputContainer.style.display = 'flex';
            chatInput.focus();
        } else {
            chatMessages.style.display = 'none';
            chatInputContainer.style.display = 'none';
        }
    });
    
    // Send chat on button click
    chatSend.addEventListener('click', sendChat);
    
    // Send chat on Enter key
    chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            sendChat();
        }
    });
    
    // Function to send chat
    function sendChat() {
        const message = chatInput.value.trim();
        
        if (message) {
            // Clear input
            chatInput.value = '';
            
            // Add to local chat
            addChatMessage(playerPublicKey, message);
            
            // Publish chat event
            publishGameEvent({
                type: 'chat',
                event_kind: GAME_EVENT_KINDS.CHAT,
                message: message
            });
        }
    }
    
    // Function to add chat message to display
    window.addChatMessage = function(pubkey, message) {
        const metadata = playerMetadata[pubkey] || { name: 'Anonymous' };
        
        const messageElement = document.createElement('div');
        messageElement.className = 'chat-message';
        
        const senderElement = document.createElement('span');
        senderElement.className = 'chat-message-sender';
        senderElement.textContent = metadata.name + ': ';
        
        const textElement = document.createElement('span');
        textElement.className = 'chat-message-text';
        textElement.textContent = message;
        
        messageElement.appendChild(senderElement);
        messageElement.appendChild(textElement);
        
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // If chat is closed, flash the toggle button
        if (!chatOpen) {
            chatToggle.style.backgroundColor = '#03DAC6';
            setTimeout(() => {
                chatToggle.style.backgroundColor = '#BB86FC';
            }, 1000);
        }
    };
}

// Initialize chat system when page loads
window.addEventListener('load', function() {
    addChatSystem();
});

// ==================== INITIALIZE ENHANCEMENT ====================

// Setup enhancements when the page loads
window.addEventListener('load', function() {
    console.log('Nostr Snake Game Enhancements Loaded!');
});
    </script>
</body>
</html>
